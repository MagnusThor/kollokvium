/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./client/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./client/app.js":
/*!***********************!*\
  !*** ./client/app.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst thor_io_client_vnext_1 = __webpack_require__(/*! thor-io.client-vnext */ \"./node_modules/thor-io.client-vnext/index.js\");\nclass App {\n    connect(brokerUrl, config) {\n        var url = brokerUrl;\n        return new thor_io_client_vnext_1.ThorIOClient.Factory(url, [\"broker\"]);\n    }\n    constructor() {\n        let fullScreenVideo = document.querySelector(\".full\");\n        let slug = document.querySelector(\"#slug\");\n        let startButton = document.querySelector(\"button\");\n        slug.addEventListener(\"keyup\", () => {\n            if (slug.value.length >= 6) {\n                startButton.disabled = false;\n            }\n            else {\n                startButton.disabled = true;\n            }\n        });\n        const addRemoteVideo = (mediaStream, peerId) => {\n            let video = document.createElement(\"video\");\n            video.srcObject = mediaStream;\n            video.setAttribute(\"id\", \"p\" + peerId);\n            video.autoplay = true;\n            document.querySelector(\".remote\").append(video);\n            document.querySelector(\".remote\").classList.remove(\"hide\");\n            video.addEventListener(\"click\", (e) => {\n                fullScreenVideo.play();\n                fullScreenVideo.srcObject = e.target.srcObject;\n            });\n        };\n        const addLocalVideo = (mediaStream) => {\n            let video = document.querySelector(\".local video\");\n            video.srcObject = mediaStream;\n        };\n        const rtcConfig = {\n            \"iceTransports\": 'all',\n            \"rtcpMuxPolicy\": \"require\",\n            \"bundlePolicy\": \"max-bundle\",\n            \"iceServers\": [\n                {\n                    \"urls\": \"stun:stun.l.google.com:19302\"\n                }\n            ]\n        };\n        startButton.addEventListener(\"click\", () => {\n            startButton.classList.add(\"hide\");\n            document.querySelector(\".overlay\").classList.add(\"d-none\");\n            document.querySelector(\".join\").classList.add(\"d-none\");\n            this.rtcClient.ChangeContext(slug.value);\n        });\n        // if local ws://localhost:1337/     \n        this.factory = this.connect(\"wss://simpleconf.herokuapp.com/\", {});\n        this.factory.OnClose = (reason) => {\n            console.error(reason);\n        };\n        this.factory.OnOpen = (broker) => {\n            console.log(\"OnOpen\", broker);\n            this.rtcClient = new thor_io_client_vnext_1.ThorIOClient.WebRTC(broker, rtcConfig);\n            this.rtcClient.OnLocalStream = (mediaStream) => {\n            };\n            // this will fire when url has a parameter\n            this.rtcClient.OnContextConnected = (ctx) => {\n            };\n            this.rtcClient.OnContextCreated = (ctx) => {\n            };\n            this.rtcClient.OnContextChanged = (ctx) => {\n                this.rtcClient.ConnectContext();\n                console.log(\"looks like we are abut to join a context...\", ctx);\n            };\n            this.rtcClient.OnContextDisconnected = (peer) => {\n                console.log(\"lost connection to\", peer);\n                document.querySelector(\"#p\" + peer.id).remove();\n            };\n            this.rtcClient.OnContextConnected = (peer) => {\n                console.log(\"connected to\", peer);\n                addRemoteVideo(peer.stream, peer.id);\n            };\n            this.rtcClient.OnRemoteTrack = (track, connection) => {\n                console.log(\"looks like we got a remote media steamTrack\", track);\n                // addRemoteVideo(mediaStream);\n            };\n            this.rtcClient.OnContextCreated = function (ctx) {\n                console.log(\"got a context from the broker\", ctx);\n            };\n            broker.OnOpen = (ci) => {\n                console.log(\"connected to broker\");\n                // now get a media stream for local\n                navigator.getUserMedia({\n                    video: {\n                        width: { min: 640, ideal: 1280 },\n                        height: { min: 400, ideal: 720 }\n                    }, audio: true,\n                }, (mediaStream) => {\n                    this.rtcClient.AddLocalStream(mediaStream);\n                    addLocalVideo(mediaStream);\n                }, (err) => {\n                    console.error(err);\n                });\n            };\n            broker.Connect();\n            window[\"T\"] = this.rtcClient;\n        };\n    }\n    static getInstance() {\n        return new App();\n    }\n}\nexports.App = App;\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    App.getInstance();\n});\n\n\n//# sourceURL=webpack:///./client/app.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/ThorIOClient.js":
/*!***********************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/ThorIOClient.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ThorIOClient;\n(function (ThorIOClient) {\n    var BinaryMessage = /** @class */ (function () {\n        function BinaryMessage(message, arrayBuffer) {\n            this.arrayBuffer = arrayBuffer;\n            this.header = new Uint8Array(ThorIOClient.Utils.longToArray(message.length));\n            this.Buffer = this.joinBuffers(this.joinBuffers(this.header.buffer, ThorIOClient.Utils.stingToBuffer(message).buffer), arrayBuffer);\n        }\n        BinaryMessage.fromArrayBuffer = function (buffer) {\n            var bytes = new Uint8Array(buffer);\n            var header = bytes.slice(0, 8);\n            var payloadLength = ThorIOClient.Utils.arrayToLong(header);\n            var start = header.byteLength + payloadLength;\n            var bytesMessage = bytes.slice(header.byteLength, start);\n            var stop = buffer.byteLength - start;\n            var messageBuffer = bytes.slice(start, stop);\n            var message = JSON.parse(String.fromCharCode.apply(null, new Uint16Array(bytesMessage)));\n            return new Message(message.T, message.D, message.C, messageBuffer);\n        };\n        BinaryMessage.prototype.joinBuffers = function (a, b) {\n            var newBuffer = new Uint8Array(a.byteLength + b.byteLength);\n            newBuffer.set(new Uint8Array(a), 0);\n            newBuffer.set(new Uint8Array(b), a.byteLength);\n            return newBuffer.buffer;\n        };\n        return BinaryMessage;\n    }());\n    ThorIOClient.BinaryMessage = BinaryMessage;\n    var Message = /** @class */ (function () {\n        function Message(topic, object, controller, buffer) {\n            this.D = object;\n            this.T = topic;\n            this.C = controller;\n            this.B = buffer;\n        }\n        Object.defineProperty(Message.prototype, \"JSON\", {\n            get: function () {\n                return {\n                    T: this.T,\n                    D: JSON.stringify(this.D),\n                    C: this.C\n                };\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Message.prototype.toString = function () {\n            return JSON.stringify(this.JSON);\n        };\n        Message.fromArrayBuffer = function (buffer) {\n            return ThorIOClient.BinaryMessage.fromArrayBuffer(buffer);\n        };\n        return Message;\n    }());\n    ThorIOClient.Message = Message;\n    var PeerConnection = /** @class */ (function () {\n        function PeerConnection() {\n        }\n        return PeerConnection;\n    }());\n    ThorIOClient.PeerConnection = PeerConnection;\n    var WebRTCConnection = /** @class */ (function () {\n        function WebRTCConnection(id, rtcPeerConnection) {\n            this.id = id;\n            this.RTCPeer = rtcPeerConnection;\n            this.stream = new MediaStream();\n        }\n        return WebRTCConnection;\n    }());\n    ThorIOClient.WebRTCConnection = WebRTCConnection;\n    var Recorder = /** @class */ (function () {\n        function Recorder(stream, mimeType, ignoreMutedMedia) {\n            var _this = this;\n            this.stream = stream;\n            this.mimeType = mimeType;\n            this.ignoreMutedMedia = ignoreMutedMedia;\n            this.recorder = new MediaRecorder(stream, { mimeType: mimeType, ignoreMutedMedia: ignoreMutedMedia });\n            this.recorder.onstop = function (event) {\n                _this.handleStop(event);\n            };\n            this.recorder.ondataavailable = function (event) {\n                _this.handleDataAvailable(event);\n            };\n        }\n        Recorder.prototype.handleStop = function (event) {\n            this.IsRecording = false;\n            var blob = new Blob(this.blobs, { type: this.mimeType });\n            this.OnRecordComplated.apply(event, [blob, URL.createObjectURL(blob)]);\n        };\n        Recorder.prototype.OnRecordComplated = function (blob, blobUrl) { };\n        Recorder.prototype.handleDataAvailable = function (event) {\n            if (event.data.size > 0) {\n                this.blobs.push(event.data);\n            }\n        };\n        Recorder.prototype.IsTypeSupported = function (type) {\n            throw \"not yet implemented\";\n        };\n        Recorder.prototype.GetStats = function () {\n            return {\n                videoBitsPerSecond: this.recorder.videoBitsPerSecond,\n                audioBitsPerSecond: this.recorder.audioBitsPerSecond\n            };\n        };\n        Recorder.prototype.Stop = function () {\n            this.recorder.stop();\n        };\n        Recorder.prototype.Start = function (ms) {\n            this.blobs = new Array();\n            if (this.IsRecording) {\n                this.Stop();\n                return;\n            }\n            this.blobs.length = 0;\n            this.IsRecording = true;\n            this.recorder.start(ms || 100);\n        };\n        return Recorder;\n    }());\n    ThorIOClient.Recorder = Recorder;\n    var PeerChannel = /** @class */ (function () {\n        function PeerChannel(peerId, dataChannel, label) {\n            this.peerId = peerId;\n            this.dataChannel = dataChannel;\n            this.label = label; // name\n        }\n        return PeerChannel;\n    }());\n    ThorIOClient.PeerChannel = PeerChannel;\n    var DataChannel = /** @class */ (function () {\n        function DataChannel(name, listeners) {\n            this.listeners = listeners || new Array();\n            this.PeerChannels = new Array();\n            this.Name = name;\n        }\n        DataChannel.prototype.On = function (topic, fn) {\n            var listener = new ThorIOClient.Listener(topic, fn);\n            this.listeners.push(listener);\n            return listener;\n        };\n        ;\n        DataChannel.prototype.OnOpen = function (event, peerId) { };\n        ;\n        DataChannel.prototype.OnClose = function (event, peerId) { };\n        DataChannel.prototype.OnMessage = function (event) {\n            var msg = JSON.parse(event.data);\n            var listener = this.findListener(msg.T);\n            if (listener)\n                listener.fn.apply(this, [JSON.parse(msg.D)]);\n        };\n        DataChannel.prototype.Close = function () {\n            this.PeerChannels.forEach(function (pc) {\n                pc.dataChannel.close();\n            });\n        };\n        DataChannel.prototype.findListener = function (topic) {\n            var listener = this.listeners.filter(function (pre) {\n                return pre.topic === topic;\n            });\n            return listener[0];\n        };\n        DataChannel.prototype.Off = function (topic) {\n            var index = this.listeners.indexOf(this.findListener(topic));\n            if (index >= 0)\n                this.listeners.splice(index, 1);\n        };\n        ;\n        DataChannel.prototype.Invoke = function (topic, data, controller) {\n            var _this = this;\n            this.PeerChannels.forEach(function (channel) {\n                if (channel.dataChannel.readyState === \"open\") {\n                    channel.dataChannel.send(new ThorIOClient.Message(topic, data, _this.Name).toString());\n                }\n            });\n            return this;\n        };\n        DataChannel.prototype.AddPeerChannel = function (pc) {\n            this.PeerChannels.push(pc);\n        };\n        DataChannel.prototype.RemovePeerChannel = function (id, dataChannel) {\n            var match = this.PeerChannels.filter(function (p) {\n                return p.peerId === id;\n            })[0];\n            var index = this.PeerChannels.indexOf(match);\n            if (index > -1)\n                this.PeerChannels.splice(index, 1);\n        };\n        return DataChannel;\n    }());\n    ThorIOClient.DataChannel = DataChannel;\n    var BandwidthConstraints = /** @class */ (function () {\n        function BandwidthConstraints(videobandwidth, audiobandwidth) {\n            this.videobandwidth = videobandwidth;\n            this.audiobandwidth = audiobandwidth;\n        }\n        return BandwidthConstraints;\n    }());\n    ThorIOClient.BandwidthConstraints = BandwidthConstraints;\n    var WebRTC = /** @class */ (function () {\n        function WebRTC(brokerProxy, rtcConfig) {\n            var _this = this;\n            this.brokerProxy = brokerProxy;\n            this.rtcConfig = rtcConfig;\n            this.getPeerIndex = function (id) {\n                return this.Peers.findIndex(function (pre) { return pre.id === id; });\n            };\n            this.Errors = new Array();\n            this.DataChannels = new Array();\n            this.Peers = new Array();\n            this.LocalStreams = new Array();\n            this.signalHandlers();\n            brokerProxy.On(\"contextCreated\", function (peer) {\n                _this.LocalPeerId = peer.peerId;\n                _this.Context = peer.context;\n                _this.OnContextCreated(peer);\n            });\n            brokerProxy.On(\"contextChanged\", function (context) {\n                _this.Context = context;\n                _this.OnContextChanged(context);\n            });\n            brokerProxy.On(\"connectTo\", function (peers) {\n                _this.OnConnectTo(peers);\n            });\n        }\n        WebRTC.prototype.setBandwithConstraints = function (videobandwidth, audiobandwidth) {\n            this.bandwidthConstraints = new BandwidthConstraints(videobandwidth, audiobandwidth);\n        };\n        WebRTC.prototype.setMediaBitrates = function (sdp) {\n            return this.setMediaBitrate(this.setMediaBitrate(sdp, \"video\", this.bandwidthConstraints.videobandwidth), \"audio\", this.bandwidthConstraints.audiobandwidth);\n        };\n        WebRTC.prototype.setMediaBitrate = function (sdp, media, bitrate) {\n            var lines = sdp.split(\"\\n\");\n            var line = -1;\n            for (var i = 0; i < lines.length; i++) {\n                if (lines[i].indexOf(\"m=\" + media) === 0) {\n                    line = i;\n                    break;\n                }\n            }\n            if (line === -1) {\n                return sdp;\n            }\n            line++;\n            while (lines[line].indexOf(\"i=\") === 0 || lines[line].indexOf(\"c=\") === 0) {\n                line++;\n            }\n            if (lines[line].indexOf(\"b\") === 0) {\n                lines[line] = \"b=AS:\" + bitrate;\n                return lines.join(\"\\n\");\n            }\n            var newLines = lines.slice(0, line);\n            newLines.push(\"b=AS:\" + bitrate);\n            newLines = newLines.concat(lines.slice(line, lines.length));\n            return newLines.join(\"\\n\");\n        };\n        WebRTC.prototype.CreateDataChannel = function (name) {\n            var channel = new DataChannel(name);\n            this.DataChannels.push(channel);\n            return channel;\n        };\n        WebRTC.prototype.RemoveDataChannel = function (name) {\n            var match = this.DataChannels.filter(function (p) { return p.Name === name; })[0];\n            this.DataChannels.splice(this.DataChannels.indexOf(match), 1);\n        };\n        WebRTC.prototype.signalHandlers = function () {\n            var _this = this;\n            this.brokerProxy.On(\"contextSignal\", function (signal) {\n                var msg = JSON.parse(signal.message);\n                switch (msg.type) {\n                    case \"offer\":\n                        _this.onOffer(signal);\n                        break;\n                    case \"answer\":\n                        _this.onAnswer(signal);\n                        break;\n                    case \"candidate\":\n                        _this.onCandidate(signal);\n                        break;\n                    default:\n                        // do op\n                        break;\n                }\n            });\n        };\n        WebRTC.prototype.addError = function (err) {\n            this.OnError(err);\n        };\n        WebRTC.prototype.OnConnectTo = function (peerConnections) {\n            this.Connect(peerConnections);\n        };\n        WebRTC.prototype.OnConnected = function (peerId) {\n            this.OnContextConnected(this.findPeerConnection(peerId), this.getPeerConnection(peerId));\n        };\n        WebRTC.prototype.OnDisconnected = function (peerId) {\n            var peerConnection = this.getPeerConnection(peerId);\n            this.OnContextDisconnected(this.findPeerConnection(peerId), peerConnection);\n            peerConnection.close();\n            this.removePeerConnection(peerId);\n        };\n        WebRTC.prototype.onCandidate = function (event) {\n            var _this = this;\n            var msg = JSON.parse(event.message);\n            var candidate = msg.iceCandidate;\n            var pc = this.getPeerConnection(event.sender);\n            pc.addIceCandidate(new RTCIceCandidate(candidate)).then(function () {\n            }).catch(function (err) {\n                _this.addError(err);\n            });\n        };\n        WebRTC.prototype.onAnswer = function (event) {\n            var _this = this;\n            var pc = this.getPeerConnection(event.sender);\n            pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(event.message))).then(function (p) {\n            }).catch(function (err) {\n                _this.addError(err);\n            });\n        };\n        WebRTC.prototype.onOffer = function (event) {\n            var _this = this;\n            var pc = this.getPeerConnection(event.sender);\n            this.LocalStreams.forEach(function (stream) {\n                stream.getTracks().forEach(function (track) {\n                    pc.addTrack(track, stream);\n                });\n            });\n            pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(event.message)));\n            pc.createAnswer({ offerToReceiveAudio: true, offerToReceiveVideo: true }).then(function (description) {\n                pc.setLocalDescription(description).then(function () {\n                    if (_this.bandwidthConstraints)\n                        description.sdp = _this.setMediaBitrates(description.sdp);\n                    var answer = {\n                        sender: _this.LocalPeerId,\n                        recipient: event.sender,\n                        message: JSON.stringify(description)\n                    };\n                    _this.brokerProxy.Invoke(\"contextSignal\", answer);\n                }).catch(function (err) { return _this.addError(err); });\n            }).catch(function (err) { return _this.addError(err); });\n        };\n        WebRTC.prototype.AddLocalStream = function (stream) {\n            this.LocalStreams.push(stream);\n            return this;\n        };\n        WebRTC.prototype.AddIceServer = function (iceServer) {\n            this.rtcConfig.iceServers.push(iceServer);\n            return this;\n        };\n        WebRTC.prototype.removePeerConnection = function (id) {\n            var connection = this.Peers.filter(function (conn) {\n                return conn.id === id;\n            })[0];\n            var index = this.Peers.indexOf(connection);\n            if (index > -1)\n                this.Peers.splice(index, 1);\n        };\n        WebRTC.prototype.createPeerConnection = function (id) {\n            var _this = this;\n            var rtcPeerConnection = new RTCPeerConnection(this.rtcConfig);\n            rtcPeerConnection.onsignalingstatechange = function (state) { };\n            rtcPeerConnection.onicecandidate = function (event) {\n                if (!event || !event.candidate)\n                    return;\n                if (event.candidate) {\n                    var msg = {\n                        sender: _this.LocalPeerId,\n                        recipient: id,\n                        message: JSON.stringify({\n                            type: 'candidate',\n                            iceCandidate: event.candidate\n                        })\n                    };\n                    _this.brokerProxy.Invoke(\"contextSignal\", msg);\n                }\n            };\n            rtcPeerConnection.oniceconnectionstatechange = function (event) {\n                switch (event.target.iceConnectionState) {\n                    case \"connected\":\n                        _this.OnConnected(id);\n                        break;\n                    case \"disconnected\":\n                        _this.OnDisconnected(id);\n                        break;\n                }\n                ;\n            };\n            rtcPeerConnection.ontrack = function (event) {\n                var connection = _this.Peers.filter(function (p) {\n                    return p.id === id;\n                })[0];\n                connection.stream.addTrack(event.track);\n                _this.OnRemoteTrack(event.track, connection);\n            };\n            this.DataChannels.forEach(function (dataChannel) {\n                var pc = new PeerChannel(id, rtcPeerConnection.createDataChannel(dataChannel.Name), dataChannel.Name);\n                dataChannel.AddPeerChannel(pc);\n                rtcPeerConnection.ondatachannel = function (event) {\n                    var channel = event.channel;\n                    channel.onopen = function (event) {\n                        dataChannel.OnOpen(event, id);\n                    };\n                    channel.onclose = function (event) {\n                        dataChannel.RemovePeerChannel(id, event.target);\n                        dataChannel.OnClose(event, id);\n                    };\n                    channel.onmessage = function (message) {\n                        dataChannel.OnMessage(message);\n                    };\n                };\n            });\n            return rtcPeerConnection;\n        };\n        WebRTC.prototype.findPeerConnection = function (id) {\n            var i = this.getPeerIndex(id);\n            return this.Peers[i];\n        };\n        WebRTC.prototype.reconnectAll = function () {\n            var _this = this;\n            var peers = this.Peers.map(function (peer) {\n                var p = new PeerConnection();\n                p.peerId = peer.id;\n                p.context = _this.Context;\n                return p;\n            });\n            this.Peers = new Array();\n            this.Connect(peers);\n            return peers;\n        };\n        WebRTC.prototype.getPeerConnection = function (id) {\n            var match = this.Peers.filter(function (connection) {\n                return connection.id === id;\n            });\n            if (match.length === 0) {\n                var pc = new WebRTCConnection(id, this.createPeerConnection(id));\n                this.Peers.push(pc);\n                return pc.RTCPeer;\n            }\n            return match[0].RTCPeer;\n        };\n        WebRTC.prototype.createOffer = function (peer) {\n            var _this = this;\n            var peerConnection = this.createPeerConnection(peer.peerId);\n            this.LocalStreams.forEach(function (stream) {\n                //peerConnection.addStream(stream);\n                stream.getTracks().forEach(function (track) {\n                    peerConnection.addTrack(track, stream);\n                });\n                _this.OnLocalStream(stream);\n            });\n            peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }).then(function (description) {\n                peerConnection.setLocalDescription(description).then(function () {\n                    if (_this.bandwidthConstraints)\n                        description.sdp = _this.setMediaBitrates(description.sdp);\n                    var offer = {\n                        sender: _this.LocalPeerId,\n                        recipient: peer.peerId,\n                        message: JSON.stringify(description)\n                    };\n                    _this.brokerProxy.Invoke(\"contextSignal\", offer);\n                }).catch(function (err) {\n                    _this.addError(err);\n                });\n            }).catch(function (err) {\n                _this.addError(err);\n            });\n            return peerConnection;\n        };\n        WebRTC.prototype.Disconnect = function () {\n            this.Peers.forEach(function (connection) {\n                connection.RTCPeer.close();\n            });\n            this.ChangeContext(Math.random().toString(36).substring(2));\n        };\n        WebRTC.prototype.DisconnectPeer = function (id) {\n            var peer = this.findPeerConnection(id);\n            peer.RTCPeer.close();\n        };\n        WebRTC.prototype.Connect = function (peerConnections) {\n            var _this = this;\n            peerConnections.forEach(function (peerConnection) {\n                var pc = new WebRTCConnection(peerConnection.peerId, _this.createOffer(peerConnection));\n                _this.Peers.push(pc);\n            });\n            return this;\n        };\n        WebRTC.prototype.ChangeContext = function (context) {\n            this.brokerProxy.Invoke(\"changeContext\", { context: context });\n            return this;\n        };\n        WebRTC.prototype.ConnectPeers = function () {\n            this.brokerProxy.Invoke(\"connectContext\", {});\n        };\n        WebRTC.prototype.ConnectContext = function () {\n            this.ConnectPeers();\n        };\n        return WebRTC;\n    }());\n    ThorIOClient.WebRTC = WebRTC;\n    var Factory = /** @class */ (function () {\n        function Factory(url, controllers, params) {\n            var _this = this;\n            this.url = url;\n            this.proxys = new Array();\n            this.ws = new WebSocket(url + this.toQuery(params || {}));\n            this.ws.binaryType = \"arraybuffer\";\n            controllers.forEach(function (alias) {\n                _this.proxys.push(new Proxy(alias, _this.ws));\n            });\n            this.ws.onmessage = function (event) {\n                if (typeof (event.data) !== \"object\") {\n                    var message = JSON.parse(event.data);\n                    _this.GetProxy(message.C).Dispatch(message.T, message.D);\n                }\n                else {\n                    var message = ThorIOClient.BinaryMessage.fromArrayBuffer(event.data);\n                    _this.GetProxy(message.C).Dispatch(message.T, message.D, message.B);\n                }\n            };\n            this.ws.onclose = function (event) {\n                _this.IsConnected = false;\n                _this.OnClose.apply(_this, [event]);\n            };\n            this.ws.onerror = function (error) {\n                _this.OnError.apply(_this, [error]);\n            };\n            this.ws.onopen = function (event) {\n                _this.IsConnected = true;\n                _this.OnOpen.apply(_this, _this.proxys);\n            };\n        }\n        Factory.prototype.toQuery = function (obj) {\n            return \"?\" + Object.keys(obj).map(function (key) { return (encodeURIComponent(key) + \"=\" +\n                encodeURIComponent(obj[key])); }).join(\"&\");\n        };\n        Factory.prototype.Close = function () {\n            this.ws.close();\n        };\n        ;\n        Factory.prototype.GetProxy = function (alias) {\n            var channel = this.proxys.filter(function (pre) { return (pre.alias === alias); });\n            return channel[0];\n        };\n        ;\n        Factory.prototype.RemoveProxy = function (alias) {\n            var index = this.proxys.indexOf(this.GetProxy(alias));\n            this.proxys.splice(index, 1);\n        };\n        Factory.prototype.OnOpen = function (proxys) { };\n        ;\n        Factory.prototype.OnError = function (error) { };\n        Factory.prototype.OnClose = function (event) { };\n        return Factory;\n    }());\n    ThorIOClient.Factory = Factory;\n    var Listener = /** @class */ (function () {\n        function Listener(topic, fn) {\n            this.fn = fn;\n            this.topic = topic;\n            this.count = 0;\n        }\n        return Listener;\n    }());\n    ThorIOClient.Listener = Listener;\n    var Utils = /** @class */ (function () {\n        function Utils() {\n        }\n        Utils.stingToBuffer = function (str) {\n            var len = str.length;\n            var arr = new Array(len);\n            for (var i = 0; i < len; i++) {\n                arr[i] = str.charCodeAt(i) & 0xFF;\n            }\n            return new Uint8Array(arr);\n        };\n        Utils.arrayToLong = function (byteArray) {\n            var value = 0;\n            var byteLength = byteArray.byteLength;\n            for (var i = byteLength - 1; i >= 0; i--) {\n                value = (value * 256) + byteArray[i];\n            }\n            return value;\n        };\n        Utils.longToArray = function (long) {\n            var byteArray = new Uint8Array(8);\n            var byteLength = byteArray.length;\n            for (var index = 0; index < byteLength; index++) {\n                var byte = long & 0xff;\n                byteArray[index] = byte;\n                long = (long - byte) / 256;\n            }\n            return byteArray;\n        };\n        Utils.newGuid = function () {\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n            }\n            ;\n            return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + s4() + s4();\n        };\n        return Utils;\n    }());\n    ThorIOClient.Utils = Utils;\n    var PropertyMessage = /** @class */ (function () {\n        function PropertyMessage() {\n            this.messageId = ThorIOClient.Utils.newGuid();\n        }\n        return PropertyMessage;\n    }());\n    ThorIOClient.PropertyMessage = PropertyMessage;\n    var Proxy = /** @class */ (function () {\n        function Proxy(alias, ws) {\n            var _this = this;\n            this.alias = alias;\n            this.ws = ws;\n            this.listeners = new Array();\n            this.IsConnected = false;\n            this.On(\"___error\", function (err) {\n                _this.OnError(err);\n            });\n        }\n        Proxy.prototype.OnError = function (event) { };\n        Proxy.prototype.OnOpen = function (event) { };\n        Proxy.prototype.OnClose = function (event) { };\n        Proxy.prototype.Connect = function () {\n            this.ws.send(new ThorIOClient.Message(\"___connect\", {}, this.alias).toString());\n            return this;\n        };\n        ;\n        Proxy.prototype.Close = function () {\n            this.ws.send(new ThorIOClient.Message(\"___close\", {}, this.alias).toString());\n            return this;\n        };\n        ;\n        Proxy.prototype.Subscribe = function (topic, callback) {\n            this.ws.send(new ThorIOClient.Message(\"___subscribe\", {\n                topic: topic,\n                controller: this.alias\n            }, this.alias).toString());\n            return this.On(topic, callback);\n        };\n        ;\n        Proxy.prototype.Unsubscribe = function (topic) {\n            this.ws.send(new ThorIOClient.Message(\"___unsubscribe\", {\n                topic: topic,\n                controller: this.alias\n            }, this.alias).toString());\n        };\n        ;\n        Proxy.prototype.On = function (topic, fn) {\n            var listener = new ThorIOClient.Listener(topic, fn);\n            this.listeners.push(listener);\n            return listener;\n        };\n        ;\n        Proxy.prototype.findListener = function (topic) {\n            var listener = this.listeners.filter(function (pre) {\n                return pre.topic === topic;\n            });\n            return listener[0];\n        };\n        Proxy.prototype.Off = function (topic) {\n            var index = this.listeners.indexOf(this.findListener(topic));\n            if (index >= 0)\n                this.listeners.splice(index, 1);\n        };\n        ;\n        Proxy.prototype.InvokeBinary = function (buffer) {\n            if (buffer instanceof ArrayBuffer) {\n                this.ws.send(buffer);\n                return this;\n            }\n            else {\n                throw (\"parameter provided must be an ArrayBuffer constructed by Client.BinaryMessage\");\n            }\n        };\n        Proxy.prototype.PublishBinary = function (buffer) {\n            if (buffer instanceof ArrayBuffer) {\n                this.ws.send(buffer);\n                return this;\n            }\n            else {\n                throw (\"parameter provided must be an ArrayBuffer constructed by Client.BinaryMessage\");\n            }\n        };\n        Proxy.prototype.Invoke = function (topic, data, controller) {\n            this.ws.send(new ThorIOClient.Message(topic, data, controller || this.alias).toString());\n            return this;\n        };\n        ;\n        Proxy.prototype.Publish = function (topic, data, controller) {\n            this.ws.send(new ThorIOClient.Message(topic, data, controller || this.alias).toString());\n            return this;\n        };\n        ;\n        Proxy.prototype.SetProperty = function (propName, propValue, controller) {\n            this.Invoke(propName, propValue, controller || this.alias);\n            return this;\n        };\n        ;\n        Proxy.prototype.Dispatch = function (topic, data, buffer) {\n            if (topic === \"___open\") {\n                this.IsConnected = true;\n                this.OnOpen(JSON.parse(data));\n                return;\n            }\n            else if (topic === \"___close\") {\n                this.OnClose([JSON.parse(data)]);\n                this.IsConnected = false;\n            }\n            else {\n                var listener = this.findListener(topic);\n                if (listener)\n                    listener.fn(JSON.parse(data), buffer);\n            }\n        };\n        ;\n        return Proxy;\n    }());\n    ThorIOClient.Proxy = Proxy;\n})(ThorIOClient = exports.ThorIOClient || (exports.ThorIOClient = {}));\n//# sourceMappingURL=ThorIOClient.js.map\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/ThorIOClient.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/index.js":
/*!****************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./ThorIOClient */ \"./node_modules/thor-io.client-vnext/ThorIOClient.js\"));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/index.js?");

/***/ })

/******/ });